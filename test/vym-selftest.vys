// vym selftest script

vym.clearConsole();

var tests_total  = 0;
var tests_passed = 0;
var tests_failed = 0;

var testDir = "selftests";
var currentMapPath = "undefined."
var testMapDefault = "test/maps/test-default.vym";
var testMapFrames  = "test/maps/test-frames.vym";

const  center_0_string = "mc:0";
const  main_A_string = "mc:0,bo:0";
const    branch_0Aa_string = main_A_string + ",bo:0";
const    branch_0Ab_string = main_A_string + ",bo:1";
const    branch_0Ac_string = main_A_string + ",bo:2";
const  main_B_string="mc:0,bo:1";
const    branch_0Ba_string = main_B_string + ",bo:0";
const    branch_0Bb_string = main_B_string + ",bo:1";
const  center_1_string = "mc:1";
const  center_2_string = "mc:2";
const  center_3_string = "mc:3";


// Compare and log values
function expect(comment, v_real, v_expected) {
	tests_total = tests_total +1;
    if (v_real == v_expected) {
        vym.print ("PASS: " + comment);
		tests_passed = tests_passed +1;
    } else {
        vym.print ("FAIL: '" + comment + "' - Expected \"" + v_expected + "\", but got \"" + v_real + "\"");
		tests_failed = tests_failed +1;
    throw "Test failed.";
    }
}

function expectInclude(comment, s, substring)
{
  if( s.includes(substring)) {
    vym.print("PASS: " + comment);
    tests_passed = tests_passed + 1;
    // waitkey
  } else {
    vym.print("FAIL: " + comment + ". Could not find \"" + substring + "\" in string below:");
    vym.print("\"" + s + "\"");
    tests_failed = tests_failed - 1;
    throw "Test failed.";
  }
  tests_total =tests_total + 1;
}

function expectNot(comment, v_real, v_expected) {
	tests_total = tests_total +1;
    if (v_real != v_expected) {
        vym.print("PASS: " + comment);
		tests_passed = tests_passed +1;
    } else {
        vym.print("FAIL: '" + comment + "' - Expected differemt values, but got " + v_expected + " and " + v_real);
		tests_failed = tests_failed +1;
    }
}


function initMap(mapPath)  // FIXME not fully ported yet: files parameter missing
{
  // Copy the map referenced above to @testDir/test-current.[vym|xml]
  // and try to load it
  currentMapPath = testDir + "/maps/current-map.vym";
  if (vym.fileExists(currentMapPath)) {
      vym.print("# Removing existing map: " + currentMapPath);
      vym.fileRemove(currentMapPath);
  }

  vym.fileCopy(mapPath, currentMapPath);

    /*  Copy additional files, not yet implemented here
  files.each do |fn|
    begin
      FileUtils.cp fn, @testDir
      puts "# Copied #{fn} to #{@testDir}".light_black
    rescue
      puts "Failed to copy #{fn} to #{@testDir}".red
      exit
    end
  end
  */

  if (vym.loadMap(currentMapPath)) {
    let id = vym.currentMapID();
    vym.print("# Loaded " + currentMapPath + " (id: " + id + "  original: " + mapPath + ")");
    vym.gotoMap(id);

    map = vym.currentMap();
    b_main_A = map.findBranchById("{19840979-9f88-475c-8627-02e3066c8216}");

    return map;
  }

  throw "Failed to load \"" + mapPath + "\"";
}

function closeCurrentMap()
{
  id = vym.currentMapID();
  name = vym.currentMap().getFileName();
  if(vym.closeMapWithID(id)) {
    vym.print("# Closed map \"" + name + "\" (id: #{id})");
  } else {
    vym.print("# Failed to close map with id = #{id}. CurrentMapID = #{id}");
  }
}

function heading(h)
{
    vym.print("\n=== " + h + "===\n");
}

function summary()
{
  heading("Summary");
	vym.print ("Tests total: " + tests_total);
	vym.print ("Tests passed: " + tests_passed);
	vym.print ("Tests failed: " + tests_failed);
}

function test_vym()
{

  heading("Mainwindow checks:");
  version = "2.9.518"
  // FIXME expect_warning_only "Version is #{version}", @vym.version, version

  // FIXME expect "Temporary directory exists at '#{@testDir}'", File.exists?(@testDir), true


  map = initMap(testMapDefault);
  //expect ("init_map copies default testmap to '#{@currentMapPath}'", File.file?(@currentMapPath), true);
  //expect ("Title of copied map title is accessible and not empty", map.getMapTitle.length > 0, true);

  closeCurrentMap();
}

function test_basics()
{
  heading("Basic checks:");
  map = initMap(testMapDefault);
  title = "vym map used for testing";
  expect("map title is \"" + title +"\"", map.getMapTitle(), title);
  author ="Uwe Drechsel";
  expect("Author is \"" + author + "\"", map.getMapAuthor(), author);

  map.select(main_A_string);
  main_A = map.selectedBranch();
  expect ("select mainbranch A", map.getSelectionString(), main_A_string);
  expect ("headingText", main_A.headingText(), "Main A");
  expect ("branchCount", main_A.branchCount(), 3);

  main_A.selectLastBranch();
  b = map.selectedBranch();  
  expect("selectLastBranch", b.headingText(), "Main B");

  main_A.selectFirstBranch();
  b = map.selectedBranch();  
  expect("selectFirstBranch", b.headingText(), "Main A");

  b.selectParent();
  b = map.selectedBranch();  
  expect("selectParent", b.headingText(), "MapCenter 0");

  //expect("getDestPath", map.getDestPath(), testDir + "/test-current.vym");
  //expect("getFileDir", map.getFileDir(), testDir + "/");

  closeCurrentMap();
}

function test_adding_branches()
{
  heading("Adding branches:");
  map = initMap(testMapDefault);
  
  map.select(main_A_string);
  main_A = map.selectedBranch();
  n = main_A.branchCount();

  main_A.addBranch();
  expect("addBranch", main_A.branchCount(), n + 1 );

  map.selectLatestAdded();
  expect("selectLatestAdded", map.getSelectionString(), main_A_string + ",bo:3");

  b = map.selectedBranch()
  b.selectParent();
  expect("selectParent", map.getSelectionString(), main_A_string);

  map.undo();
  map.undo();   // FIXME one undo() should be enough
                // caused by VM::applyDesign() adding one more
                // saveStates

  expect( "Undo: addBranch", main_A.branchCount(), n );

  closeCurrentMap();

  map = initMap(testMapDefault);

  map.select(main_A_string);
  main_A = map.selectedBranch();
  n = main_A.branchCount();
  map.select(branch_0Aa_string);
  branch_0Aa = map.selectedBranch();
  branch_0Aa.addBranchAt( -3 );
  branch_0Aa.addBranchAt( -1 );
  expect("addBranchAbove/Below", main_A.branchCount(), n + 2);

  map.undo();
  map.undo();
  map.undo();
  map.undo();
  expect("Undo: addBranchAbove/Below", main_A.branchCount(), n);

  closeCurrentMap();

  map = initMap(testMapDefault);

  map.select(main_A_string);
  main_A = map.selectedBranch();
  map.select(branch_0Aa_string);
  branch_0Aa = map.selectedBranch();
  branch_0Aa.addBranchBefore();
  expect("addBranchBefore: check branchcount",  main_A.branchCount(), n);
  branch_0Aa.selectParent();
  b = map.selectedBranch();
  expectNot("addBranchBefore: heading is not 'Main A'", b.headingText(), "Main A");
  expectNot("addBranchBefore: heading is not 'branch a'", b.headingText(), "branch a");

  // Undo twice: addBranchNew and relinkTo
  map.undo();
  map.undo();
  expect("Undo: addBranchBefore", main_A.branchCount(), n);

  closeCurrentMap();
}

function test_adding_maps()
{
  heading("Adding maps");
  let map = initMap(testMapDefault);
  map.select(branch_0Aa);
  n = map.branchCount()
  map.addMapReplace(currentMapPath);
  map.select(main_A);
  expect("addMapReplace: check branch count in #{@main_A}", map.branchCount(), n + 1);
  map.select(branch_0Aa);
  expect("addMapReplace: check if #{@branch_0Aa} is new", map.branchCount(), 2);
  expect("addMapReplace: Loaded MapCenter 0", map.getHeadingPlainText(), "MapCenter 0");
  map.select(branch_0Ab);
  expect("addMapReplace: Loaded MapCenter 1", map.getHeadingPlainText(), "MapCenter 1");

  map.undo()
  map.select(main_A);
  expect("Undo: check branch count in #{@main_A}", map.branchCount(), 3);
  map.select(branch_0Aa);
  expect("Undo: check if #{@branch_0Aa} is back", map.branchCount(), 3);
  closeCurrentMap();

  map = initMap(testMapDefault);
  map.select(branch_0Aa);
  n = map.branchCount();
  map.addMapInsert(currentMapPath, 1) // Create testmap with several MCs
  map.select(branch_0Aa);
  expect("addMapInsert: branch count",  map.branchCount(), n + 2);
  map.select(branch_0Aa + ",bo:1");
  expect("addMapInsert: new heading", map.getHeadingPlainText(), "MapCenter 0");
  map.select(branch_0Aa + ",bo:2");
  expect("addMapInsert: new heading", map.getHeadingPlainText(), "MapCenter 1");

  map.undo();
  map.select(branch_0Aa);
  expect("Undo: check branch count in #{@branch_0Aa}", map.branchCount(), 3);
  map.select(branch_0Ab);
  expect("Undo: check heading of  #{@branch_0Ab}",  map.getHeadingPlainText(), "branch b");
  closeCurrentMap();
}

function test_attributes()
{
  heading("Attributes:");
  
  map = initMap("maps/test-attributes.xml");

  map.select(main_A);
  b = map.selectedBranch();
  expect("String attribute is '6 * 9'", b.attributeAsString("string-attribute"), "6 * 9");
  expect("Integer attribute is 42", b.attributeAsInt("int-attribute"), 42);

  closeCurrentMap();
}

function test_copy_paste()
{
  heading("Copy and paste:");
  map = initMap(testMapDefault);
  
  map.select(main_A);

  n = map.branchCount();

  map.copy();
  map.paste();
  map.selectLatestAdded();     //FIXME-5 not set for ImportAdd, which is used by paste
  s = map.getSelectionString();
  expect("Normal paste of branch, check heading of #{s}", map.getHeadingPlainText(), "Main A");

  map.undo()
  map.select(main_A);
  expect("Undo paste: branchCount of #{@main_A}", map.branchCount(), n);

  map.redo()
  map.select(s);
  expect("redo paste: check heading", map.getHeadingPlainText(), "Main A");

  map.select(branch_0Aa);
  map.cut();
  map.select(main_A);
  expect("cut: branchCount of #{@main_A}", map.branchCount(), n);

  map.paste();
  map.selectLastChildBranch();
  s = map.getSelectionString();
  expect("Normal paste of branch, check heading of #{s}", map.getHeadingPlainText(), "branch a");

  closeCurrentMap();
}
 
function test_delete_parts()
{
  heading("Deleting parts:");
  map = initMap(testMapDefault);
  
  map.select(main_A);
  let n = map.branchCount();
  map.select(branch_0Aa);
  let m = map.branchCount();
  map.remove();
  map.select(main_A);
  expect( "Remove branch: branchcount",  map.branchCount(), n - 1);
  map.undo();
  map.select(main_A);
  expect( "Undo Remove branch: branchcount parent", map.branchCount(), n);
  map.select(branch_0Aa);
  expect( "Undo Remove branch: branchcount restored branch", map.branchCount(), m);

  closeCurrentMap();

  map = initMap(testMapDefault);
  map.select(branch_0Aa);
  n = map.branchCount();
  map.removeChildren();
  map.select(branch_0Aa);
  expect( "removeChildren: branchcount", map.branchCount(), 0);
  map.undo();
  map.select(branch_0Aa);
  expect( "Undo: removeChildren: branchcount", map.branchCount(), n);

  closeCurrentMap();

  map = initMap(testMapDefault);
  map.select(main_A);
  n = map.branchCount();
  map.select(branch_0Aa);
  map.removeKeepChildren();
  map.select(main_A);
  expect( "removeKeepChildren: branchcount", map.branchCount(), n + m - 1);
  map.undo()
  map.select(main_A);
  expect( "Undo: removeKeepChildren: branchcount of parent", map.branchCount(), n);
  map.select(branch_0Aa);
  expect( "Undo: removeKeepChildren: branchcount of branch", map.branchCount(), m);

  closeCurrentMap();

  map = initMap(testMapDefault);

  n = map.centerCount();
  map.select(center_1);
  map.remove();
  expect( "remove mapCenter: number of centers decreased", map.centerCount(), n - 1);
  map.undo();
  expect( "Undo remove mapCenter: number of centers increased", map.centerCount(), n);

  closeCurrentMap();
}

function test_export()
{
  heading("Export:");
  let map = initMap(testMapDefault);

  //HTML
  let exportdir = testDir + "/export-html";
  vym.mkdir(exportdir);
  let htmlpath = exportdir + "/output.html";
  let flagdir  = exportdir + "/flags";
  let pngpath = exportdir + "/output.png";
  let csspath = exportdir + "/vym.css";
  map.exportMap(["HTML", htmlpath, exportdir]);
  expect("exportHTML: HTML file exists", vym.fileExists(htmlpath), true);
  expect("exportHTML: HTML image exists", vym.fileExists(pngpath), true);
  expect("exportHTML: HTML flags dir exists", vym.directoryExists(flagdir), true);
  if (vym.directoryExists(flagdir))
    expect("exportHTML: HTML flags dir not empty", vym.directoryIsEmpty(flagdir), false);

  expect("exportHTML: HTML CSS exists", vym.fileExists(csspath), true);
  vym.fileExists(htmlpath);
  vym.removeDirectory(flagdir);
  vym.fileExists(pngpath);
  vym.fileExists(csspath);
  map.exportMap(["Last"]);
  expect("exportLast: HTML #{htmlpath} file exists", vym.fileExists(htmlpath), true);
  expect("exportLast: HTML image exists", vym.fileExists(pngpath), true);
  expect("exportHTML: HTML flags dir exists", vym.directoryExists(flagdir), true);
  if (vym.directoryExists(flagdir))
    expect("exportHTML: HTML flags dir not empty", vym.directoryIsEmpty(flagdir), false);

  expect("exportLast: HTML CSS exists", vym.fileExists(csspath), true);

  //AO
  exportdir = testDir + "/export-ao";
  vym.mkdir(exportdir);
  filepath = exportdir + "/output.txt";
  vym.print("filepath is " + filepath);
  map.exportMap(["AO", filepath]);
  expect("exportAO:    AO file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap("Last");
  expect("exportLast:  AO file exists", vym.fileExists(filepath), true);

  //ASCII
  exportdir = testDir + "/export-ascii";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.txt";
  map.exportMap("ASCII", filepath, false);
  expect("exportASCII: ASCII file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  ASCII file exists", vym.fileExists(filepath), true);

  //CSV
  exportdir = testDir + "/export-csv";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.csv";
  map.exportMap(["CSV", filepath]);
  expect("exportCSV:    CSV file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  CSV file exists", vym.fileExists(filepath), true);

  //Image
  exportdir = testDir + "/export-image";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.png";
  map.exportMap(["Image", filepath,"PNG"]);
  expect("exportImage: PNG file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:  PNG file exists", vym.fileExists(filepath), true);

  //LaTeX
  exportdir = testDir + "/export-latex";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.tex";
  map.exportMap(["LaTeX", filepath]);
  expect("exportLaTeX:  LaTeX file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:   LaTeX file exists", vym.fileExists(filepath), true);

  //Markdown
  exportdir = testDiri + "/export-markdown";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.md";
  map.exportMap("Markdown", filepath);
  expect("exportMarkdown:  Markdown file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:     Markdown file exists", vym.fileExists(filepath), true);

  //OrgMode
  exportdir = testDir + "/export-orgmode"
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.org";
  map.exportMap(["OrgMode", filepath]);
  expect("exportOrgMode:  OrgMode file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast:     OrgMode file exists", vym.fileExists(filepath), true);

  //PDF
  exportdir = testDir + "/export-pdf";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.pdf";
  map.exportMap(["PDF", filepath]);
  expect("exportPDF:  PDF file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: PDF file exists", vym.fileExists(filepath), true);

  //SVG
  exportdir = testDir + "/export-svg";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.svg";
  map.exportMap(["SVG", filepath]);
  expect("exportSVG:  SVG file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: SVG file exists", vym.fileExists(filepath), true);

  //XML
  exportdir = testDir  + "/export-xml";
  Dir.mkdir(exportdir);
  filepath = exportdir + "/output.xml";
  map.exportMap(["XML", filepath, testDir]);
  expect("exportXML: XML file exists", vym.fileExists(filepath), true);
  vym.removeFile(filepath);
  map.exportMap(["Last"]);
  expect("exportLast: XML file exists", vym.fileExists(filepath), true);

  //OpenOffice Impress //FIXME-5
  //Taskjuggler //FIXME-5

  closeCurrentMap();
}

function test_extrainfo()
{
  heading("Extra information");
  let map = initMap(testMapDefault);
  map.setMapAuthor("Fra Erasmas");
  expect("Set and get map author", map.getMapAuthor(), "Fra Erasmas");
  map.setMapComment("xy z");
  expect("Set and get map comment", map.getMapComment(), "xy z");
  map.setMapTitle("vym rules!");
  expect("Set and get map title", map.getMapTitle(), "vym rules!");

  closeCurrentMap();
}

function  test_frames()
{
  heading("Frames:");
  map = initMap(testMapFrames);

  map.select(center_0);
  expect("Mapcenter of " + center_0 + " has no inner frame", map.getFrameType(true), "NoFrame");
  expect("Mapcenter of " + center_0 + " has no outer frame", map.getFrameType(true), "NoFrame");

  map.select(center_1);
  expect("Mapcenter of " + center_1 + " has no inner frame", map.getFrameType(true), "NoFrame");
  expectNot("Mapcenter of " + center_1 + " has outer frame", map.getFrameType(false), "NoFrame");

  map.select(center_2);
  expectNot("Mapcenter of " + center_2 + " has inner frame", map.getFrameType(true), "NoFrame");
  expect("Mapcenter of " + center_2 + " has no outer frame", map.getFrameType(false), "NoFrame");

  map.select(center_3);
  expectNot("Mapcenter of " + center_3 + " has inner frame", map.getFrameType(true), "NoFrame");
  expectNot("Mapcenter of " + center_3 + " has outer frame", map.getFrameType(false), "NoFrame");
  closeCurrentMap();
}

function test_history()
{
  heading("History");

  map = initMap(testMapDefault);

  map.select(main_A);
  let b = map.selectedBranch();
  map.setHeadingPlainText("A");
  map.setHeadingPlainText("B");
  map.setHeadingPlainText("C");
  map.undo();
  map.undo();
  map.undo();
  expect("Undo 3 times, after changing heading -> 'A' -> 'B' -> 'C'", b.headingText(), "Main A");
  map.redo();
  expect("Redo once", map.getHeadingPlainText(), "A");
  map.copy();
  map.redo();
  expect("Redo once more", map.getHeadingPlainText(), "B");
  map.redo();
  expect("Redo yet again", map.getHeadingPlainText(), "C");
  map.setHeadingPlainText("Main A");
  map.paste();
  map.selectLastChildBranch()
  expect("Paste from the past", map.getHeadingPlainText(), "A");
  map.remove();

  closeCurrentMap();
}

function test_load_legacy_maps()
{
  heading("Load legacy maps");

  let map = initMap("maps/legacy/legacy-text-2.4.0.xml");
  map.select(branch_0Aa);
  expect("Heading with plaintext as characters is read", map.getHeadingPlainText(), "Heading in characters");

  map.select(center_0);
  expect("Checking parsing 'absPos': x-position of " + center_0 + " is ok", map.getPosX(), 314);
  expect("Checking parsing 'absPos': y-position of " + center_0 + " is ok", map.getPosY(), 0);
  map.select(main_A);

  // FIXME-2 Review setting relative positions from legacy maps,
  // probable there is an offset meanwhile
  //expect("Checking parsing 'relPos': x-position of " + main_A + " is ok", map.getPosX(), 123);
  //expect("Checking parsing 'relPos': y-position of " + main_A + " is ok", map.getPosY(), 42);

  closeCurrentMap();

  map = initMap("maps/legacy/time-management-1.13.33.vym");
  map.select(main_A);
  let s = "To see an explanation";
  expect("<heading> using characters: Heading includes '#{s}'", map.getHeadingPlainText().includes(s), true);
  expect("<vymnote> using <html>: creates RichText note", map.hasRichTextNote(), true);
  s = "time management";
  expect("<vymnote> using <html>: Note contains '#{s}'", map.getNotePlainText().includes(s), true);

  closeCurrentMap();

  map = initMap("maps/legacy/lifeforms-2.1.11.vym");
  map.select(center_0);

  s = "Life forms";
  expect("<heading> using characters and HTML: includes '#{s}'", map.getHeadingXML().includes(s), true);
  s = "textMode=\"richText";
  expect("<heading> using characters creates RichText", map.getHeadingXML().includes(s), true);

  closeCurrentMap();

  map = initMap("maps/legacy/faq-2.5.21.xml");
  map.select(branch_0Ab);

  s = "libqt5-devel.rpm";
  expect("<vymnote> using characters and CDATA: has RichText note", map.hasRichTextNote(), true);
  expect("<vymnote> using characters and CDATA: includes '#{s}'", map.getNotePlainText().includes(s), true);
  expect("<vymnote> using characters and CDATA: has RichText note", map.hasRichTextNote(), true);

  map.select(branch_0Ac);
  s = "textMode=\"richText";
  expect("<heading> using characters and CDATA: creates RichText", map.getHeadingXML().includes(s), true);
  s = "CDATA heading";
  expect("<heading> using characters and CDATA: includes \"" + s + "\"", map.getHeadingPlainText().includes(s), true);

  closeCurrentMap();


  files = [
    "maps/legacy/external-note-plaintext.txt",
    "maps/legacy/external-note-richtext.html" ];
  /* FIXME-2 Loading files not supported yet
  map = initMap("maps/legacy/notes.xml", files);
  */

  map = initMap("maps/legacy/notes.xml");

  map.select(branch_0Aa);
  expect("<note> with plaintext in external file: text has type PlainText",
    map.hasRichTextNote(), false);
  expectInclude("<note> with plaintext in external file: text is read correctly",
    map.getNotePlainText(),
    "PlainText note in file");

  map.select(branch_0Ab);
  expect("<note> with plaintext in characters: text has type PlainText",
    map.hasRichTextNote(), false);
  expectInclude( "<note> reads plaintext from characters",
    map.getNotePlainText(),
    "PlainText note in characters");

  map.select(branch_0Ac);
  expect("<note> with RichText in external file: text has type RichText",
    map.hasRichTextNote(), true);
  expectInclude( "<note> reads RichText from external file",
    map.getNotePlainText(),
    "RichText note in file");
  map.select(branch_0Ab);

  map.select(branch_0Ba);
  expect("<htmlnote> with PlainText in characters: text has type PlainText",
    map.hasRichTextNote(), false);
  expectInclude( "<htmlnote> reads PlainText from characters",
    map.getNotePlainText(),
    "PlainText note in characters");
  map.select(branch_0Bb);

  // Note: 1.4.0 maps might have a 2nd DTD preceding inline HTML
  // THis would be invalid XML and thus QXMLStreamReader cannot read
  // it. Workaround: Remove DTD manually
  expect("<htmlnote> with RichText in characters: text has type RichText",
    map.hasRichTextNote(), true);
  expectInclude( "<htmlnote> reads RichText from characters",
    map.getNotePlainText(),
    "RichText note in characters");

  closeCurrentMap();

  map = initMap("maps/legacy/xlinks.xml");
  // FIXME-5 add test: xlinks in subitems of branches (pre 1.13.2)
  map.select(main_A);
  expect("<xlink> within <branch> is read", map.xlinkCount(), 1);

  map.selectXLinkOtherEnd(0);
  expect("<xlink> connects  '#{@main_A}' and '#{@main_B}'", map.getSelectionString(), main_B);
  closeCurrentMap();
}

function test_scrolling()
{
  heading("Scrolling and unscrolling:");
  map = initMap(testMapDefault);
  
  map.select(main_A);
 
  let b = map.selectedBranch();
  map.toggleScroll();
  expect("toggleScroll", b.isScrolled(), true);
  map.undo()
  expect("undo toggleScroll", b.isScrolled(), false);
  b.scroll();
  expect("scroll", b.isScrolled(), true);
  b.unscroll();
  expect("unscroll", b.isScrolled(), false);

  b.scroll();
  map.select(branch_0Aa);
  map.scroll();
  map.select(main_A);
  map.unscrollChildren();
  map.select(branch_0Aa);
  expect("unscrollChildren", map.isScrolled(), false);
  map.undo();
  map.select(branch_0Aa);
  expect("undo unscrollChildren", map.isScrolled(), true);

  closeCurrentMap();
}

function test_modify_branches()
{
  heading("Modifying branches");
  let map = initMap(testMapDefault);

  map.select(branch_0Aa);
  map.setHeadingPlainText("Changed!");
  expect("setHeadingPlainText", map.getHeadingPlainText(), "Changed!");
  map.undo();
  expect("Undo: setHeadingPlainText", map.getHeadingPlainText(), "branch a");
  map.redo();
  expect("redo: setHeadingPlainText", map.getHeadingPlainText(), "Changed!");
  map.undo();

  closeCurrentMap();
}

function test_moving_parts()
{
  heading("Moving parts");
  let map = initMap(testMapDefault);

  map.select(branch_0Aa);
  map.moveDown();
  map.select(branch_0Aa);
  expect("Moving down", map.getHeadingPlainText(), "branch b");
  map.undo();
  map.select(branch_0Aa);
  expect("Undo Moving down", map.getHeadingPlainText(), "branch a");

  //let map = init_map( vym );
  map.select(branch_0Ab);
  map.moveUp();
  map.select(branch_0Aa);
  expect("Moving up", map.getHeadingPlainText(), "branch b");
  map.undo();
  map.select(branch_0Ab);
  expect("Undo Moving up", map.getHeadingPlainText(), "branch b");

  //let map = init_map( vym );
  map.select(main_B);
  n=map.branchCount();
  map.select(branch_0Aa);
  map.relinkTo(main_B,0,0,0);
  map.select(main_B);
  expect("RelinkTo #{@main_B}: branchCount increased there",  map.branchCount(), n+1);

  map.undo();
  map.select(branch_0Ab);
  expect("Undo: RelinkTo #{@main_B}: branchCount decreased there", map.branchCount(), n);

  //let map = init_map( vym );
  map.select(main_A);
  err = map.relinkTo(branch_0Aa,0,0,0);
  //FIXME-5 disabled, error not supported atm expect_error "RelinkTo myself fails.", err);

  //let map = init_map( vym );
  map.select(branch_0Aa);
  n=map.branchCount();
  map.select(main_B);
  map.relinkTo(branch_0Aa, 1, 0, 0);
  map.select(branch_0Aa);
  expect("RelinkTo #{@branch_0Aa}, pos 1: branchCount increased there",  map.branchCount(), n+1);
  map.select(branch_0Aa + ",bo:1");
  expect("RelinkTo #{@branch_0Aa}, pos 1: Mainbranch really moved", map.getHeadingPlainText(), "Main B");
  map.undo();
  map.select(center_0);
  expect("Undo RelinkTo pos 1: branchCount of center", map.branchCount(), 2);

  closeCurrentMap();
}

function test_notes()
{
  heading("Notes:");

  // Plaintext notes basic actions
  let map = initMap(testMapDefault);

  map.select(main_A);
  note_plain = "vymnote plaintext";
  map.setNotePlainText(note_plain);
  expect("Set note to \"#{note_plain}\". Still plaintext?", map.hasRichTextNote(), false);
  map.select(center_0);
  map.select(main_A);
  expect("After reselect, is note plaintext?", map.hasRichTextNote(), false);

  note_plain = "<b>plaintext, not bold!</b>"
  map.setNotePlainText(note_plain);
  expect("Set note to plaintext containing html tags. Still plaintext", map.hasRichTextNote(), false);
  note_new = map.getNotePlainText();
  map.select(center_0);
  map.select(main_A);
  expect("After reselect, is note text unchanged?", map.getNotePlainText(), note_new);
  expect("After reselect, is note plaintext?", map.hasRichTextNote(), false);

  // Plaintext notes copy & paste
  map.copy();
  map.paste();
  map.selectLastChildBranch();
  s = map.getSelectionString();
  expect("After copy& paste: New note unchanged?", map.getNotePlainText(), note_plain);
  expect("After copy& paste: New note Still plaintext?", map.hasRichTextNote(), false);
  map.remove();

  // Plaintext notes undo & redo
  map.select(main_A);
  map.setNotePlainText('Foobar');
  map.undo();
  expect("Undo after setNotePlainText restores previous note", map.getNotePlainText(), note_plain);
  map.redo();
  map.select(main_A);
  expect("Redo restores previous note", map.getNotePlainText(), 'Foobar');

  // Plaintext notes load & save
  note_org = vym.loadFile('notes/note-plain.txt');
  map.loadNote("test/notes/note-plain.txt");
  expect("Load plain text note from file. Still plaintext?", map.hasRichTextNote(), false);
  expect("Note contains 'not bold'", map.getNotePlainText().includes("not bold"), true);
  filepath = testDir + "/save-note.txt";
  map.saveNote(filepath);
  expect("Save note to file. Check if it contains 'textMode=\"plainText\"'", vym.loadFile(filepath).includes("textMode=\"plainText\""), true);
  expect("Save note to file. Check if it contains 'not bold'", vym.loadFile(filepath).includes("not bold"), true);
  expect("Save note to file. Check new format: no longer contains '<b>' element",vym.loadFile(filepath).includes("<b>"), false);
  expect("Save note to file. Check new format: no longer contains '<![CDATA['",vym.loadFile(filepath).includes("<![CDATA["), false);
  expect("Save note to file. Check new format: contains 'text=\"Plaintext'",vym.loadFile(filepath).includes("text=\"Plaintext"), true);

  // Delete note
  map.setNotePlainText("");
  expect("setNotePlainText(\"\") deletes note", map.hasNote(), false);

  closeCurrentMap();

  // RichText basic actions
  map = initMap(testMapDefault);
  rt_note = '<html><body style=" font-family:"Arial"; font-size:12pt; font-weight:400; font-style:normal;"> <p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:"DejaVu Sans Mono"; color:#000000;">Rich Text note with <b>not bold text</b></span></p></body></html>]]></vymnote>'
  b_main_A.setNoteRichText(rt_note);
  expect("b.setNoteRichText produces note", b_main_A.hasNote(), true);
  expect("b.setNoteRichText produces richText note", b_main_A.hasRichTextNote(), true);
  expect("After reselect, is note RichText?", b_main_A.hasRichTextNote(), true);


  // RichText notes copy & paste
  b_main_A.select();
  rt_note = map.getNoteXML();
  map.copy();
  map.paste();
  map.selectLastChildBranch();
  b = map.selectedBranch();
  expect("After copy & paste: New note still RichText?", b.hasRichTextNote(), true);
  expect("After copy & paste: New note unchanged?", b.getNoteXML(), rt_note);
  map.remove();

  // RichText notes undo & redo
  map.select(main_A);
  map.setNotePlainText('Foobar');
  map.undo();
  expect("Undo after setNotePlainText restores RichText note", map.getNoteXML(), rt_note);
  map.redo();
  map.select(main_A);
  expect("Redo restores previous plaintext note", map.getNotePlainText(), 'Foobar');

  // RichText notes load & save
  map.loadNote("test/notes/note.html");
  expect("Load HTML note from file and try to detect textMode. Is RichText?", map.hasRichTextNote(), true);
  filepath = testDir + "/save-note.txt";
  map.saveNote(filepath);
  expect("Save note to file. Check if it contains 'textMode=\"richText\"'", vym.loadFile(filepath).includes("textMode=\"richText\""), true);
  expect("Save note to file. Check if it contains 'bold'", vym.loadFile(filepath).includes("bold"), true);
  expect("Save note to file. Check new format: no longer contains '<b>' element", vym.loadFile(filepath).includes("<b>"), false);
  expect("Save note to file. Check new format: no longer contains '<![CDATA['", vym.loadFile(filepath).includes("<![CDATA["), false);
  expect("Save note to file. Check new format: contains 'text=\"&lt;'", vym.loadFile(filepath).includes("text=\"&lt;"), true);

  // Delete note
  map.setNotePlainText("");
  expect("setNotePlainText(\"\") deletes note", map.hasNote(), false);

  // Compatibility with notes from version < 2.5.0  # FIXME-3 missing

  closeCurrentMap();
}

function test_references()
{
  heading("References");
  let map = initMap(testMapDefault);

  map.select(main_A);
  url = "www.insilmaril.de";
  map.setUrl(url);
  expect("setUrl to '#{url}'", map.getUrl(), url);

  map.undo();
  expect("undo setUrl", map.getUrl(), "");
  map.redo();
  expect("redo setUrl", map.getUrl(), url);
  map.setUrl("");
  expect("setUrl: unset Url with empty string", map.getUrl(), "");

  vl = "default.vym";
  map.setVymLink(vl);
  s = map.getVymLink();
  expect("setVymLink returns absolute path", map.getFileDir() + vl, s);
  map.undo();
  expect("undo: setVymLink", map.getVymLink(), "");
  map.redo();
  expect("redo: setVymLink", map.getVymLink(), s);
  map.undo

  closeCurrentMap();
}

function test_saving()
{
  heading("Saving");
  let map = initMap(testMapDefault);

  // Save selection without overwriting original map);
  map.select(branch_0Aa);
  let mapName = "test-saveSelection.vyp";
  let fn = testDir + "/" + mapName;
  map.saveSelection(fn);
  expect(
      "Save selection: '" + branch_0Aa + "' to '" + fn + "'",
      vym.fileExists(fn),
      true);

  closeCurrentMap();

  map = initMap(mapName);
  map.select(center_0);
  expect(
      "Save selection: After loading of '" + mapName + "' '" + center_0 + "' is ok",
      map.getHeadingPlainText(),
      "branch a");
  map.select(main_A);
  expect(
      "Save selection: After loading of '" + mapName + "' '" + main_A + "'  is ok",
      map.getHeadingPlainText(),
      "branch a1");

  closeCurrentMap();
}

function test_slides()
{
  heading("Slides");
  let map = initMap("maps/test-slides.xml");

  map.select(main_A);
  expect("Successfully loaded map with slides", map.slideCount(), 3);

  closeCurrentMap()
}

function test_standard_flags()
{
  heading("Standard flags");
  let map = initMap(testMapDefault);
  map.select(main_A);

  function set_flag (f, index, array)
  {
    map.setFlagByName(f);
    vym.print("#Setting flag: " + f);  
    expect("Flag set: '" + f +"'", map.hasActiveFlag(f), true);
  }

  function unset_flag (f, index, array)
  {
    map.unsetFlagByName(f);
    vym.print("#Unetting flag: " + f);  
    expect("Flag unset: '" + f +"'", map.hasActiveFlag(f), false);
  }

  // Group standard-mark
  for (flag of [ "exclamationmark","questionmark"])
    set_flag(flag);

  // Group standard-status
  for( flag of [ "hook-green",
    "wip",
    "cross-red",
    "stopsign" ] )
    unset_flag(flag);	

  // Group standard-smiley
  smileys = [ "smiley-good",
      "smiley-sad",
      "smiley-omb" ];
  for (flag of smileys )
    set_flag(flag);

  // Group standard-arrow
  arrows = [ "arrow-up",
    "arrow-down",
    "2arrow-up",
    "2arrow-down" ];
  for (flag of arrows)
    set_flag(flag);

  // Group standard-thumb
  for (flag of [ "thumb-up", "thumb-down" ] )
    set_flag(flag);

  // Without group
  divflags = [ "clock",
    "phone",
    "lamp",
    "rose",
    "heart",
    "present",
    "flash",
    "info",

    "lifebelt" ];
  for (flag of divflags)  
    set_flag(flag);

  expect(
      "Heart flag is set",
      map.hasActiveFlag("heart"),
      true);
      
  for (flag of smileys )
    unset_flag(flag);

  expect(
      "Smiley flag is no longerset",
      map.hasActiveFlag("smiley"),
      false);
      
  map.clearFlags();

  expect("clearFlags cleared exclamationmark", map.hasActiveFlag( "exclamationmark" ), false);
  expect("clearFlags cleared smiley-good", map.hasActiveFlag( "smiley-good" ), false);


  // Toggling flags
  flags = ["stopsign", "lifebelt"]
  for (flag of flags) {
    map.toggleFlagByName(flag);
    expect("toggleFlag: flag '" + flag + "' activated", map.hasActiveFlag(flag), true);

    map.toggleFlagByName(flag);
    expect("toggleFlag: flag '" + flag + "' deactivated", map.hasActiveFlag(flag), false);
  }

  closeCurrentMap();
}


function test_user_flags()
{
  heading("User flags");
  let map = initMap("maps/test-userflag.vym");

  map.select(branch_0Aa);
  flagName = "userflag-vym";
  expect("Has active flag '" + flagName + "'", map.hasActiveFlag(flagName), true);

  closeCurrentMap();
}


function test_xlinks()
{
  heading("XLinks:");
  let map = initMap(testMapDefault);

  map.select(main_A);
  n = map.xlinkCount()
  map.addXLink(main_A, main_B, 2,"#ff0000","Qt::DashDotLine");
  expect("xlink count increased after creating xlink", map.xlinkCount(), n + 1);
  map.selectXLink(0);
  expect("Default color of XLink", map.getXLinkColor(), "#ff0000");
  expect("Default width of XLink", map.getXLinkWidth(), 2);
  expect("Default style of XLink", map.getXLinkPenStyle(), "Qt::DashDotLine");
  expect("Default style of XLink begin", map.getXLinkStyleBegin(), "HeadFull");
  expect("Default style of XLink end",   map.getXLinkStyleEnd(), "HeadFull");

  map.setXLinkWidth(3);
  expect("New width of XLink", map.getXLinkWidth(), 3);
  map.undo();
  expect("Undo width of XLink", map.getXLinkWidth(), 2);

  map.setXLinkColor("#00ff00");
  expect("New color of XLink", map.getXLinkColor(), "#00ff00");
  map.undo();
  expect("Undo color of XLink", map.getXLinkColor(), "#ff0000");

  map.setXLinkStyle("Qt::SolidLine");
  expect("New style of XLink", map.getXLinkPenStyle(), "Qt::SolidLine");
  map.undo();
  expect("Undo style of XLink", map.getXLinkPenStyle(), "Qt::DashDotLine");

  map.setXLinkStyleBegin("None");
  expect("New style of XLink begin", map.getXLinkStyleBegin(), "None");
  map.undo();
  expect("Undo style of XLink begin", map.getXLinkStyleBegin(), "HeadFull");

  map.setXLinkStyleEnd("None");
  expect("New style of XLink end", map.getXLinkStyleEnd(), "None");
  map.undo();
  expect("Undo style of XLink end", map.getXLinkStyleEnd(), "HeadFull");

  map.select(main_A);
  map.selectXLinkOtherEnd(0);
  expect(
      "xlink connects  '" + main_A + "'' and '" + main_B + "'",
      map.getSelectionString(),
      main_B);

  closeCurrentMap();
}

function test_tasks()
{
  heading("Tasks");
  let map = initMap("maps/test-tasks.xml");

  map.select(branch_0Aa);
  expect("After loading '" +branch_0Aa + "' has no task", map.hasTask(), false);

  map.select(branch_0Ab);
  expect("After loading '" + branch_0Ab + "' has task", map.hasTask(), true);
  expect("After loading '" + branch_0Ab + "' task sleeps more than 1000 days",
	map.getTaskSleepDays() > 1000,
	true);

  map.select(branch_0Aa);
  map.toggleTask();
  expect("Toggle task", map.hasTask(), true);

/* FIXME-2 Date functions used in ruby tests not available here yet
  date_today = DateTime.now
  delta_days = 123
  date_later = date_today + delta_days
  date_later_iso = date_later.strftime("%Y-%m-%dT%H:%M:%S");

  // Input: number of days
  date_new = delta_days
  expect("Set task sleep to number of days '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);
  expect("Set task sleep to number of days '#{date_new}' has correct sleep value '#{delta_days}' days", map.getTaskSleepDays(), delta_days);

  // Input: number of seconds
  date_new = "10s"
  expect("Set task sleep to number of seconds '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);

  // Input: number of hours
  date_new = "10h"
  expect("Set task sleep to number of hours '#{date_new}' accepts input", map.setTaskSleep(date_new),  true);

  // Input: Date
  date_new = date_later.strftime("%Y-%m-%d");
  expect("Set task sleep to ISO Date '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to ISO Date '#{date_new}' has correct sleep value '#{delta_days}' days", map.getTaskSleepDays(), delta_days);

  date_new = date_later.strftime("%d.%m.");
  expect("Set task sleep to German short form '#{date_new}' accepts input '#{date_new}'", map.setTaskSleep(date_new), true);
  expect("Set task sleep to German short form '#{date_new}' has correct sleep value (days)", map.getTaskSleepDays(), delta_days);

  date_new = date_later.strftime("%d.%m.%Y");
  expect("Set task sleep to German long form '#{date_new}' accepts input '#{date_new}'", map.setTaskSleep(date_new), true);
  expect("Set task sleep to German long form '#{date_new}' has correct sleep value (days)", map.getTaskSleepDays(), delta_days);

  // Input: Invalid strings
  date_new = "invalidDate"
  expect("Set task sleep to '#{date_new}' should fail", map.setTaskSleep(date_new), false);

  date_new = date_later.strftime("%d %m.%Y");
  expect("Set task sleep to '#{date_new}' should fail", map.setTaskSleep(date_new), false);

  // DateTime
  date_new = date_later_iso
  expect("Set task sleep to ISO DateTime '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to ISO DateTime '#{date_new}' returns correct sleep value '#{date_later_iso}'", map.getTaskSleep, date_later_iso);

  // Time only
  date_later = date_today

  date_new = "12:34"
  date_later_iso = date_today.strftime("%Y-%m-%dT12:34:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso

  date_new = "2:4"
  date_later_iso = date_today.strftime("%Y-%m-%dT02:04:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso

  date_new = "03:05"
  date_later_iso = date_today.strftime("%Y-%m-%dT03:05:00");
  expect("Set task sleep to time '#{date_new}' accepts input", map.setTaskSleep(date_new), true);
  expect("Set task sleep to time '#{date_new}' returns correct sleep value '#{date_later_iso}'",);
    map.getTaskSleep, date_later_iso
    */

  closeCurrentMap();
}


///////////////////////////////////////////////////////////////
//  Auto porting end
///////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////

// test_vym();  // FIXME currently not used (version check, tmpDir check)

test_basics();          // ok, already uses BranchWrapper
test_adding_branches(); // ok, already uses BranchWrapper
/*
test_adding_maps();
test_attributes();
test_copy_paste();
test_delete_parts();
*/
//test_export(); // FIXME WIP
//test_notes();
/*
test_extrainfo();
test_frames();
test_history();
test_load_legacy_maps();
test_modify_branches();
test_moving_parts();
test_notes();
test_references();
test_saving();
test_scrolling();
test_slides();
test_standard_flags();
test_tasks();	// FIXME-2 uncomplete (date calculations)
test_user_flags();
test_xlinks();
*/

summary();